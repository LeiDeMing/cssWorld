## 内联元素与流
> 内联元素默认是基线对齐的
### 字母 x——CSS 世界中隐匿的举足轻重的角色
> 我们这里的字母 x 就是 26 个英文字母中的 x。由于自身形态的一些特殊性，这个小小的不起眼的字母担当大任，在 CSS 世界中扮演了一个重要的角色。可能有人的第一反应是：“我知道，可以模拟关闭按钮的那个叉叉效果！”这位朋友思维很活跃，但是，我们这里说的并不是字母 x 在 CSS 世界中的奇技淫巧，而是正统的术语上的紧密联系。

#### 字母 x 与 CSS 世界的基线
> 内联相关模型中，凡是涉及垂直方向的排版或者对齐的，都离不开最基本的基线
> 基线又是如何定义的吗？基线的定义就离不开本文的主角 x。字母 x 的下边缘（线）就是我们的基线。参见[如图](http://ww1.sinaimg.cn/large/0060ZzrAgy1g7tzjryecnj30cd05nq35.jpg)所示的标示

#### 字母 x 与 CSS 中的 x-height
> CSS 中有一个概念叫作 x-height，指的是字母 x 的高度,通俗地讲，x-height 指的就是小写字母 x 的高度，术语描述就是基线和等分线（mean line）（也称作中线，midline）之间的距离
> 最典型的代表就是 verticalalign:middle。这里的 middle 是中间的意思。注意，跟上面的 median（中线）不是一个意思,我们可以近似理解为字母 x 交叉点那个位置
> 对于内联元素垂直居中应该是对文字，而非居外部的块级容器所

#### 字母 x 与 CSS 中的 ex
> ex 是 CSS 中地地道道的一个尺寸单位
> 连 IE6 都老早支持的 ex 是 CSS 中的一个相对单位，指的是小写字母 x 的高度，没错，就是指 x-height。
>  [如图](http://ww1.sinaimg.cn/large/0060ZzrAgy1g7u0iwr069j3048019743.jpg) 所示的文字后面跟着一个小三角形图标的效果是非常常见的。现在，要让该图标和文字中间位置对齐，你会如何实现？设定好尺寸，然后使用 vertical-align:middle？这样虽然也有效果，但是，实际上啰嗦了，借助 ex 单位，我们直接利用默认的 baseline 基线对齐就可以实现这个效果

    icon-arrow { 
        display: inline-block; 
        width: 20px; 
        height: 1ex; 
        background: url(arrow.png) no-repeat center; 
    }

### 内联元素的基石 line-height
#### 内联元素的高度之本—line-height
> 如果仅仅通过表象来确认，估计不少人会认为\<div>高度是由里面的文字撑开的，也就是font-size 决定的，但本质上是由 line-height 属性全权决定的，尽管某些场景确实与font-size 大小有关
> 对于非替换元素的纯内联元素，其可视高度完全由 line-height 决定
> 内联元素的高度由固定高度和不固定高度组成，这个不固定的部分就是这里的“行距”。换句话说，line-height 之所以起作用，就是通过改变“行距”来实现的
> 在 CSS 中，“行距”分散在当前文字的上方和下方，也就是即使是第一行文字，其上方也是有“行距”的，只不过这个“行距”的高度仅仅是完整“行距”高度的一半，因此，也被称为“半行距”
> 半行距,一般业界的共识是：行距 = 行高− em-box。转换成 CSS 语言就是：行距 = line-height - font-size。
> 中 em-box 是 CSS 世界中比较虚的一个概念，说“虚”并不是胡编乱造的意思，而是我们无法有效感知这个盒子具体的位置在哪里，但是有一点可以明确，就是其高度正好就是 1em。em是一个相对 font-size 大小的 CSS 单位，因此 1em 等用于当前一个 font-size 大小
> 内容区域（content area）出马了。在本书中，内容区域可以近似理解为 Firefox/IE浏览器下文本选中带背景色的区域。
> 内容区域和 em-box 是不一样的，内容区域高度受 font-family 和font-size 双重影响，而 em-box 仅受 font-size 影响，通常内容区域高度要更高一些。除了下面这种情况，也就是“当我们的字体是宋体的时候，内容区域和 em-box 是等同的”[半行距](http://ww1.sinaimg.cn/large/0060ZzrAgy1g7u0zwxku1j30df064gmc.jpg)
> 网页中的设置的 line-height 大小，就能根据标注获取准确的间距值。举个例子，假设 line-height 是 1.5，font-size 大小是 14px，那么我们的半行距大小就是（套用上面的行距公式再除以 2）：(14px * 1.5 - 14px) / 2 = 14px * 0.25 = 3.5px
> border 以及 line-height 等传统 CSS 属性并没有小数像素的概念（从 CSS3 动画的细腻程度可以看出），因此，这里的 3.5px 需要取整处理，如果标注的是文字上边距，则向下取整；如果是文字下边距，则向上取整，因为绝大多数的字体在内容区域中都是偏下的
> 当line-height设为 2 的时候，半行距是一半的文字大小，两行文字中间的间隙差不多一个文字尺寸大小；如果 line-height 大小是 1 倍文字大小，则根据计算，半行距是 0，也就是两行文字会紧密依偎在一起；如果 line-height 值是 0.5，则此时的行距就是负值，虽然 line-height 不支持负值，但是行距可以为负值，此时，两行文字就是重叠纠缠在一起
+ A 替换元素
> + line-height不能影响替换元素（如图片的高度）
> + line-height 在这个混合元素的“行框盒子”中扮演的角色是决定这个行盒的最小高度，听上去似乎有点儿尴尬，对于纯文本元素，line-height 非常威风，直接决定了最终的高度。但是，如果同时有替换元素，则line-height 的表现一下子弱了很多，只能决定最小高度，对最终的高度表现有望尘莫及之感。为什么会这样呢？一是替换元素的高度不受 line-height 影响，二是 vertical-align属性在背后作祟。
+ B 块级元素
> + 