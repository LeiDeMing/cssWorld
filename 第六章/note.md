## 流的破坏与保护
### 魔鬼属性 float
#### float 的本质与特性
> 认为 float 属性就是为各种块状布局而设计的，实际上不是的。在 Web 诞生之初，带宽就那么一点点，我们能够做到的也只是展示文字以及零星图片而已，怎么可能浮动设计的目的就是为了实现各种砖头式的复杂布局呢？
> 浮动的本质就是为了实现文字环绕效果。而这种文字环绕，主要指的就是文字环绕图片显示的效果。
> 浮动是魔鬼，少砌砖头、少浮动，要更多地去挖掘 CSS 世界本身的“流动性”和“自适应性”，以构建能够适用于各种环境的高质量的网页布局。
> float 都有哪些有意思的特性呢?
> + 包裹性；
> + 块状化并格式化上下文；
> + 破坏文档流；
> + 没有任何 margin 合并；
> 块状化的意思是，元素一旦 float 的属性值不为 none，则其 display 计算值就是 block或者 table。
> 因此，没有任何理由出现下面的样式组合：

    span { 
        display: block; /* 多余 */ 
        float: left; 
    } 
    span { 
        float: left; 
        vertical-align: middle; /* 多余 */ 
    }

> float 属性与 display 属性值转换关系[如表](http://ww1.sinaimg.cn/large/0060ZzrAgy1g7xmt56tlcj30gi0erwf5.jpg)
> 除了 inline-table 计算为 table 外，其他全都是 block。至于 float 元素的块状格式化上下文特性，参见 6.3 节

#### float 的作用机制
> 甚至有些人会问这样的问题：“如何解决浮动让父元素高度塌陷的 bug？”bug？别逗了。一定要明确这一点，浮动使高度塌陷不是 bug，而是标准！有人可能会有疑问了：怎么会有规范让人“干坏事”的？
> float 属性让父元素高度塌陷的原因就是为了实现文字环绕效果。
>要想实现真正的“环绕效果”，就需要另外一个平时大家不太在意的特性，那就是“行框盒子和浮动元素的不可重叠性”，也就是“行框盒子如果和浮动元素的垂直高度有重叠，则行框盒子在正常定位状态下只会跟随浮动元素，而不会发生重叠”。
> 也就是“行框盒子”的区域永远就这么大，只要不改变当前布局方式，我们是无法通过其他 CSS 属性改变这个区域大小的。这就是在 4.3 节提到的浮动后面元素 margin 负无穷大依然无效的原因。就会发现，只有外部的块状容器盒子尺寸变大，而和浮动元素垂直方向有重叠的“行框盒子”依然被限死在那里.
> 我们不妨看下面这个很有学习价值的例子。很多人会有这样的想法，就是认为一个元素只要设置了具体的高度值，就不需要担心 float 属性造成的高度塌陷的问题了，既然有了高度，何来“高度塌陷”。这句话对不对呢？是对的。但是，其中也隐含了陷阱，因为“文字环绕效果”是由两个特性（即“父级高度塌陷”和“行框盒子区域限制”）共同作用的结果，定高只能解决“父级高度塌陷”带来的影响，但是对“行框盒子区域限制”却没有任何效果，结果导致的问题是浮动元素垂直区域一旦超出高度范围，或者下面元素 margin-top 负值上偏移，就很容易使后面的元素发生“环绕效果”
> 虽然肉眼看上去容器和图片一样高，但是，大家都读过5.3 节，应该都知道内联状态下的图片底部是有间隙的，也就是.float 这个浮动元素的实际高度并不是 64px，而是要比 64px 高几像素，带来的问题就是浮动元素的高度超出.father 几像素。
>[实例](http://demo.cssworld.cn/6/1-1.php)

#### float 更深入的作用机制
> + 浮动锚点是 float 元素所在的“流”中的一个点，这个点本身并不浮动，就表现而言更像一个没有 margin、border 和 padding 的空的内联元素
> + 浮动参考指的是浮动元素对齐参考的实体
> 在 CSS 世界中，float 元素的“浮动参考”是“行框盒子”，也就是 float 元素在当前“行框盒子”内定位
> 参考书6.1.3

#### float 与流体布局
> float 通过破坏正常 CSS 流实现 CSS 环绕，带来了烦人的“高度塌陷”的问题，然而，凡事都具有两面性，只要了解透彻，说不定就可以变废为宝、化腐朽为神奇。例如。我们可以利用 float 破坏 CSS 正常流的特性，实现两栏或多栏的自适应布局
> 还记不记得之前小动物环绕的例子？其实我们稍加改造，就能变成一侧定宽的两栏自适应布局，HTML 和 CSS 代码如下：

    <div class="father"> 
        <img src="me.jpg"> 
        <p class="animal">小猫 1，小猫 2，...</p> 
    </div> 
    .father { 
        overflow: hidden; 
    } 
    .father > img { 
        width: 60px; height: 64px; 
        float: left; 
    } 
    .animal { 
        margin-left: 70px; 
    }

> 和文字环绕效果相比，区别就在于.animal 多了一个 margin-left:70px，也就是所有小动物都要跟男主保持至少 70px 的距离，由于图片宽度就 60px，因此不会发生环绕，自适应效果达成。
> 原理其实很简单，.animal 元素没有浮动，也没有设置宽度，因此，流动性保持得很好，设置 margin-left、border-left 或者 padding-left 都可以自动改变 content box 的尺寸，继而实现了宽度自适应布局效果。
> [demo](http://demo.cssworld.cn/6/1-2.php)
> 上面的技巧适用于一侧定宽一侧自适应：如果是宽度不固定，也有办法处理，这会在 6.3.2 节中介绍。如果是百分比宽度，则也是可以的，例如：

    .left { 
        float: left; 
        width: 50%; 
    } 
    .right { 
        margin-left: 50%; 
    }

> 如果是多栏布局，也同样适用，尤其[图](http://ww1.sinaimg.cn/large/0060ZzrAgy1g7yrz1vkhcj30aq01hdfq.jpg)所示的这种布局
> 假设 HTML 结构如下：

    <div class="box"> 
    <a href class="prev">&laquo; 上一章</a> 
    <a href class="next">下一章 &raquo;</a> 
    <h3 class="title">第 112 章 动物环绕</h3> 
    </div>

> 则 CSS 可以如下：

    .prev { 
        float: left; 
    } 
    .next { 
        float: right; 
    } 
    .title { 
        margin: 0 70px; 
        text-align: center; 
    }

### float 的天然克星 clear
#### 什么是 clear 属性
> clear 属性值:
> + none：默认值，左右浮动来就来。
> + left：左侧抗浮动。
> + right：右侧抗浮动。
> + both：两侧抗浮动。
> 我的答案非常直白：没错，确实没有什么用！凡是 clear:left 或者 clear:right 起作用的地方，一定可以使用 clear:both 替换！

> 举个例子，假设容器宽度足够宽，有 10 个\<li>元素，设置了如下 CSS 代码：[如图](http://ww1.sinaimg.cn/large/0060ZzrAgy1g7ys7dkkqbj306801w0km.jpg)

    li { 
        width: 20px; height: 20px; 
        margin: 5px; 
        float: left; 
    } 
    li:nth-of-type(3) { 
        clear: both; 
    }

> 原因在于，clear 属性是让自身不能和前面的浮动元素相邻，注意这里“前面的”3 个字，也就是 clear 属性对“后面的”浮动元素是不闻不问的，因此才 2 行显示而非 3 行。

#### 成事不足败事有余的 clear
> clear 属性只有块级元素才有效的，而::after 等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置 display 属性值的原因。
> 由于 clear:both 的作用本质是让自己不和 float 元素在一行显示，并不是真正意义上的清除浮动，因此 float 元素一些不好的特性依然存在，于是，会有类似下面的现象
> + （1）如果 clear:both 元素前面的元素就是 float 元素，则 margin-top 负值即使设成-9999px，也不见任何效果。
> + （2）clear:both 后面的元素依旧可能会发生文字环绕的现象。举个例子，如下 HTML和 CSS：[如图](http://ww1.sinaimg.cn/large/0060ZzrAgy1g7ysde4bl9j307102pt90.jpg)

    <div class="father"> 
        <img src="zxx.jpg"> 
        我是帅哥，好巧啊，我也是帅哥，原来看这本书的人都是帅哥~ 
    </div> 
    <div>虽然你很帅，但是我对你不感兴趣。</div>
    .father:after {
        content: ''; 
        display: table; 
        clear: both; 
    } 
    .father img { 
        float:left; 
        width: 60px; height: 64px; 
    } 
    .father + div { 
        margin-top: -2px; 
    }

>由此可见，clear:both 只能在一定程度上消除浮动的影响，要想完美地去除浮动元素的影响，还需要使用其他 CSS 声明。那应该使用哪些 CSS 声明呢？请看 6.3 节

### CSS 世界的结界——BFC
#### BFC 的定义
> BFC 全称为 block formatting context，中文为“块级格式化上下文”。相对应的还有 IFC，也就是 inline formatting context，中文为“内联格式化上下”
> 大家请记住下面这个表现原则：如果一个元素具有 BFC，内部子元素再怎么翻江倒海、翻云覆雨，都不会影响外部的元素。所以，BFC 元素是不可能发生 margin 重叠的，因为 margin重叠是会影响外面的元素的；BFC 元素也可以用来清除浮动的影响，因为如果不清除，子元素浮动则父元素高度塌陷，必然会影响后面元素布局和定位，这显然有违 BFC 元素的子元素不会影响外部元素的设定。
> 那什么时候会触发 BFC 呢？常见的情况如下：
> + \<html>根元素；
> + float 的值不为 none；
> + overflow 的值为 auto、scroll 或 hidden；
> + display 的值为 table-cell、table-caption 和 inline-block 中的任何一个；
> + position 的值不为 relative 和 static。

#### BFC 与流体布局
> BFC 的结界特性最重要的用途其实不是去 margin 重叠或者是清除 float 影响，而是实现更健壮、更智能的自适应布局。
> 我们还是从最基本的文字环绕效果说起。还是那个小动物环绕的例子：我们还是从最基本的文字环绕效果说起。还是那个小动物环绕的例子：

    <div class="father"> 
    <img src="me.jpg"> 
    <p class="animal">小猫 1，小猫 2，...</p> 
    </div> 
    img { float: left; }
    
   > 此时.animal 的内容显然受到了设置了 float 属性值的图片的影响而被环绕了。此时如果我们给.animal 元素设置具有 BFC 特性的属性，overflow:hidden，如下：则根据 BFC 的表现原则，具有 BFC 特性的元素的子元素不会受外部元素影响，也不会影响外部元素。于是，这里的.animal 元素为了不和浮动元素产生任何交集，顺着浮动边缘形成自己的封闭上下文
   > 普通流体元素在设置了 overflow:hidden 后，会自动填满容器中除了浮动元素以外的剩余空间，形成自适应布局效果，而且这种自适应布局要比纯流体自适应
更加智能。
> 和基于纯流体特性实现的两栏或多栏自适应布局相比，基于 BFC 特性的自适应布局有如下优点。
> + （1）自适应内容由于封闭而更健壮，容错性更强。比方说，内部设置 clear:both 不会与float 元素相互干扰而导致错位，也就不会发生类似于图 6-22 所示的问题。
> + （2）自适应内容自动填满浮动以外区域，无须关心浮动元素宽度，可以整站大规模应用。比方说，抽象几个通用的布局类名
> 理论上，任何 BFC 元素和 float 元素相遇的时候，都可以实现自动填充的自适应布局。但是，由于绝大多数的触发 BFC 的属性自身有一些古怪的特性，所以，实际操作的时候，能兼顾流体特性和 BFC 特性来实现无敌自适应布局的属性并不多。下面我们一个一个来看，每个CSS 属性选一个代表来进行说明。
> + （1）float:left。浮动元素本身 BFC 化，然而浮动元素有破坏性和包裹性，失去了元素本身的流体自适应性，因此，无法用来实现自动填满容器的自适应布局。不过，其因兼容性还算良好，与搭积木这种现实认知匹配，上手简单，因此在旧时代被大肆使用，也就是常说的“浮动布局”，也算阴差阳错地开创了自己的一套布局。
> + （2）position:absolute。这个脱离文档流有些严重，过于清高，和非定位元素很难玩到一块儿去，我就不说什么了。
> + （3）overflow:hidden。这个超棒！不像浮动和绝对定位，玩得有点儿过。其本身还是一个很普通的元素，因此，块状元素的流体特性保存得相当完好，附上 BFC 的独立区域特性，谓如虎添翼、宇宙无敌！而且 overflow:hidden 的 BFC 特性从 IE7 浏览器开始就支持，兼容性也很不错。唯一的问题就是容器盒子外的元素可能会被隐藏掉，一定程度上限制了这种特性的大规模使用。不过，溢出隐藏的交互场景比例不算很高，所以它还是可以作为常用 BFC布局属性使用的。
> + （4）display:inline-block。这是 CSS 世界最伟大的声明之一，但是用在这里，就有些捉襟见肘了。display:inline-block 会让元素尺寸包裹收缩，完全就不是我们想要的lock 水平的流动特性。只能是一声叹息舍弃掉！然而，峰回路转，世事难料。大家应该知道，IE6 和 IE7 浏览器下，block 水平的元素设置 display:inline-block 元素还是 block 水平，也就是还是会自适应容器的可用宽度显示。于是，对于 IE6 和 IE7 浏览器，我们会阴差阳错得到一个比 overflow:hidden 更强大的声明，既 BFC 特性加身，又流体特性保留
> + （5）display:table-cell。其让元素表现得像单元格一样，IE8 及以上版本浏览器才持。跟 display:inline-block 一样，它会跟随内部元素的宽度显示，看样子也是不合适的命。但是，单元格有一个非常神奇的特性，就是宽度值设置得再大，实际宽度也会超过表格容器的宽度。第 3 章单元格一柱擎天的例子利用的就是这种特性，如图 6-23 所示
> + （6）display:table-row。对 width 无感，无法自适应剩余容器空间。
> + （7）display:table-caption。此属性一无是处。
> 我们对 BFC 声明家族大致过了一遍，能担任自适应布局重任的也就是以下几个。
> + overflow:auto/hidden，适用于 IE7 及以上版本浏览器；
> + display:inline-block，适用于 IE6 和 IE7；
> + display:table-cell，适用于 IE8 及以上版本浏览器。

### 最佳结界 overflow
> 要想彻底清除浮动的影响，最适合的属性不是 clear 而是 overflow。一般使用overflow:hidden，利用 BFC 的“结界”特性彻底解决浮动对外部或兄弟元素的影响。
不过话又说回来，overflow 属性原本的作用指定了块容器元素的内容溢出时是否需要裁剪，也就是“结界”只是其衍生出来的特性，“剪裁”才是其本职工作。

#### overflow 剪裁界线 border box
> 要尽量避免滚动容器设置 padding-bottom 值，除了样式表现不一致外，还会导致 scrollHeight 值不一样，这往往会给开发带来难以察觉的麻烦，需要引起注意。
> 了解 overflow-x 和 overflow-y
> 支持的属性值和 overflow 属性一模一样。
> + visible：默认值。
> + hidden：剪裁。
> + scroll：滚动条区域一直在。
> + auto：不足以滚动时没有滚动条，可以滚动时滚动条出现
> 这种相似性很容易让大家产生一个误区，认为只要 overflow-x 和 overflow-y 设置了上面的属性值，就一定会是这样的表现，实际上 overflow-x 和 overflow-y 的表现规则要比看上去复杂些：如果 overflow-x 和 overflow-y 属性中的一个值设置为 visible 而另外一个设置为 scroll、auto 或 hidden，则 visible 的样式表现会如同 auto。也就是说，除非 overflow-x 和 overflow-y 的属性值都是 visible，否则 visible 会当成 auto 来解析。换句话说，永远不可能实现一个方向溢出剪裁或滚动，另一方向内容溢出显示的效果。

#### overflow 与滚动条
> HTML 中有两个标签是默认可以产生滚动条的，一个是根元素<html>，另一个是文本域<textarea>。之所以可以出现滚动条，是因为这两个标签默认的 overflow 属性值不是visible，从 IE8 浏览器开始，都使用 auto 作为默认的属性值。
> 关于浏览器的滚动条，有以下几个小而美的结论。
> + （1）在 PC 端，无论是什么浏览器，默认滚动条均来自<html>，而不是<body>标签。验证很简单，新建一个空白页面，此时<body>标签的默认 margin 值是.5em，如果滚动条是由<body>标签产生的，那么效果应该如图 6-27 所示这般边缘留有间隙。但是最后实现结果却是图 6-28 所示的这样没有间隙。注意，上述规则只对 PC 端有效，对于移动端并不一定适用。例如，在 PC 端，对<html>标签设置 overflow:hidden 可以隐藏滚动条禁止滚动，但是在移动端基本上无效。在 PC 端，窗体滚动高度可以使用 document.documentElement.scrollTop 获取，但是在移动端，可能就要使用 document.body.scrollTop 获取。
> + （2）滚动条会占用容器的可用宽度或高度。
> 滚动条是可以自定义的,倒是支持-webkit-前缀的浏览器可以说说。例如，对于 Chrome 浏览器：
> + 整体部分，::-webkit-scrollbar；
> + 两端按钮，::-webkit-scrollbar-button；
> + 外层轨道，::-webkit-scrollbar-track；
> + 内层轨道，::-webkit-scrollbar-track-piece；
> + 滚动滑块，::-webkit-scrollbar-thumb；
> + 边角，::-webkit-scrollbar-corner。

#### 依赖 overflow 的样式表现
> 在 CSS 世界中，很多属性要想生效都必须要有其他 CSS 属性配合，其中有一种效果就离不开 overflow:hidden 声明，即单行文字溢出点点点效果。虽然效果的核心是 textoverflow:ellipsis，效果实现必需的 3 个声明如下：

    .ell { 
        text-overflow: ellipsis; 
        white-space: nowrap; 
        overflow: hidden; 
    }

> 目前，对-webkit-私有前缀支持良好的浏览器还可以实现多行文字打点效果，但是却无须依赖 overflow:hidden。比方说，最多显示 2 行内容，再多就打点的核心 CSS 代码如下：

    .ell-rows-2 { 
         display: -webkit-box; 
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 2;
    }

#### overflow 与锚点定位
> 下面思考这两个问题：锚点定位行为是基于什么条件触发的？锚点定位作用的发生本质上是什么在起作用？
> 1．锚点定位行为的触发条件
> + （1）URL 地址中的锚链与锚点元素对应并有交互行为；
> + （2）可 focus 的锚点元素处于 focus 状态。
> 所以我们一般实现返回顶部效果都是使用这样的 HTML：\<a href="#">返回顶部>\</a>
> 然后配合 JavaScript 实现一些动效或者避免点击时候 URL 地址出现#，而很多人实现返回顶部效果的时候使用的是类似下面的 HTML：\<a href="javascript:">返回顶部>\</a>
> 显然我是推荐上面那种做法的，因为锚点定位行为的发生是不需要依赖 JavaScript 的，所以即使页面 JavaScript 代码失效或者加载缓
慢，也不会影响正常的功能体验，也就是用户无论在什么状态下都能准确地返回顶部。
> “focus 锚点定位”指的是类似链接或者按钮、输入框等可以被 focus 的元素在被 focus时发生的页面重定位现象。举个很简单的例子，在 PC 端，我们使用 Tab 快速定位可 focus 的元素的时候，如果我们的元素正好在屏幕之外，浏览器就会自动重定位，将这个屏幕之外的元素定位到屏幕之中。
> 2．锚点定位作用的本质
> 锚点定位行为的发生，本质上是通过改变容器滚动高度或者宽度来实现的。
> “由内而外”指的是，普通元素和窗体同时可滚动的时候，会由内而外触发所有可滚动窗体的锚点定位行为。继续上面的例子，假设我们的浏览
器窗体也是可滚动的，则点击“点击测试”链接后，“底部标题”先触发.box 容器的锚点定位，也就是滚动到底部，然后再触发窗体的锚点定位，“底部标题”和浏览器窗口的上边缘对齐，[如图](http://ww1.sinaimg.cn/large/0060ZzrAgy1g85pggqiyfj306r030q2v.jpg)
> 其次就是设置了 overflow:hidden 的元素也是可滚动的，这也是本小节的核心。说得更干脆点儿就是：overflow:hidden 跟 overflow:auto 和 overflow：scroll 的差别就在于有没有那个滚动条。元素设置了 overflow:hidden 声明，里面内容高度溢出的时候，滚动依然存在，仅仅滚动条不存在！锚点定位本质上是改变了 scrollTop 或scrollLeft 值，因此，上面的定位效果等同于执行了下面的 JavaScript 代码：document.querySelector('.box').scrollTop = 200;
> 那岂不是我们可以利用这种兼容的浏览器行为实现更复杂的无 JavaScript 的交互效果？例如，实现选项卡切换效果，[点击](http://demo.cssworld.cn/6/4-2.php)
> 此效果乍一看很酷，但却有不少不足之处：其一，容器高度需要固定；其二，也是最麻烦的，就是“由内而外”的锚点定位会触发窗体的重定位，也就是说，如果页面也是可以滚动的，则点击选项卡按钮后页面会发生跳动，这种体验显然是非常不好的。那有没有什么解决办法呢？
> 有，还记不记得前面提过有两种方法可以触发锚点定位，其中有一种方法就是“focus 锚点定位”，只要定位的元素在浏览器窗体中，就不会触发窗体的滚动，也就是选项卡切换的时候页面不会发生跳动。[访问基于“focus 锚点定位”](http://demo.cssworld.cn/6/4-3.php),同样，这一技术只适用于高度固定的选项卡效果，如各大站点首页经常出现的幻灯片广告切换效果等。实际上，如果不用考虑 IE8 浏览器，可以利用:checked 伪类、单选按钮和\<label>标签的点击行为实现选项卡切换
> 实现自定义的滚动条效果，因为 Windows 系统下浏览器的滚动条会占据宽度，而且长得不好看，所以就存在实现自定义滚动条的需求，也就是类似移动端的悬浮式滚动条。传统实现都是父容器设置 overflow:hidden，然后子元素使用一个大的\<div>包起来，设置绝对定位，然后通过改变 top 值，或者使用 transform 进行偏移。但是在我看来，最推荐的实现还是基于父容器自身的 scrollTop 值改变来实现自定义滚
动条效果，其好处有如下这些。
> + （1）实实现简单，无须做边界判断。因为就算 scrollTop 设为-999，浏览器依然按照 0 来渲染，要想滚动到底部，直接一个很大的 scrollTop 值就可以了，无须任何计算。例如：container.scrollTop = 99999;
> + （2）可与原生的 scroll 事件天然集成，无缝对接。例如，我们的滚动延迟加载图片效果就可以直接应用，因为图片位置的计算往往都是和 scrollTop 值相关联的，所以传统实现scrollTop 值一直是 0，很可能导致这类组件出现异常。
> + （3）无须改变子元素的结构。传统实现为了定位方便，会给所有的列表元素外面包一层独立的\<div>元素，这可能会导致某些选择器（类似于.container > .list{}）失效，但是，基于父容器本身的 scrollTop 滚动实现则无此问题，即使子元素全是兄弟元素也是可以的。
> 当然，没有哪种技术是万能的，基于改变 overflow:hidden 父容器的 scrollTop 实现自定义滚动条效果也有几点不足：一是无法添加类似 Bounce 回弹这种动效；二是渲染要比一般的渲染慢一些，但大多数场景下用户都是无感知的。

### float 的兄弟 position:absolute
> 为 position:absolute（下简称 absolute）和 float:left/float：right（下简称 float）是兄弟关系，都兼具“块状化”“包裹性”“破坏性”等特性，不少布局场合甚至可以相互替代
> 当 absolute 和 float 同时存在的时候，float属性是无任何效果的
> 元素一旦 position 属性值为 absolute 或 fixed，其display 计算值就是 block 或者 table
> 又比方说两者都能“块状格式化上下文”，也就是 BFC。
> 又比方说两者都具有“包裹性”，也就是尺寸收缩包裹，同时具有自适应性。

#### absolute 的包含块
> 包含块（containing block）这个概念实际上大家一直都有接触，就是元素用来计算和定位的一个框。比方说，width:50%，也就是宽度一半，那到底是哪个“元素”宽度的一半呢？注意，这里的这个“元素”实际上就是指的“包含块”。有经验的人应该都知道，普通元素的百分比宽度是相对于父元素的 content box 宽度计算的，而绝对定位元素的宽度是相对于第一个position 不为 static 的祖先元素计算的。实际上，大家已经和“包含块”打过交道了，对于这些计算规则，规范是有明确定义的，具体如下（剔除了不常用的部分内容）。
> + （1）根元素（很多场景下可以看成是<html>）被称为“初始包含块”，其尺寸等同于浏览器可视窗口的大小。
> + （2）对于其他元素，如果该元素的 position 是 relative 或者 static，则“包含块”由其最近的块容器祖先盒的 content box 边界形成。
> + （3）如果元素 position:fixed，则“包含块”是“初始包含块”。
> + （4）如果元素 position:absolute，则“包含块”由最近的 position 不为 static的祖先元素建立，具体方式如下。[纯inline元素](http://ww1.sinaimg.cn/large/0060ZzrAgy1g85pz51ipxj30la05gwgf.jpg),如果该祖先元素是纯 inline 元素，则规则略复杂：
> + + 假设给内联元素的前后各生成一个宽度为 0 的内联盒子（inline box），则这两个内联盒子的 padding box 外面的包围盒就是内联元素的“包含块”；
> + + 如果该内联元素被跨行分割了，那么“包含块”是未定义的，也就是 CSS2.1规范并没有明确定义，浏览器自行发挥。
> + + 否则，“包含块”由该祖先的 padding box 边界形成。
> + + 如果没有符合条件的祖先元素，则“包含块”是“初始包含块”。
> + 可以看到，和常规元素相比，absolute 绝对定位元素的“包含块”有以下 3 个明显差异：
> + + （1）内联元素也可以作为“包含块”所在的元素；
> + + （2）“包含块”所在的元素不是父块级元素，而是最近的 position 不为 static 的祖先元素或根元素；
> + + （3）边界是 padding box 而不是 content box。
> + 首先讲第一点差异，也就是内联元素可以作为“包含块”。这一点估计很多人都不知道，因为平时使用得少。为何平时用得少？原因如下。
> + + （1）我们一旦使用 absolute 绝对定位，基本上都是用来布局，而内联元素主要的作用是图文展示，所谓道不同不相为谋，因此两者很难凑到一块儿。
> + + （2）理解和学习成本比较高。
> + + （3）兼容性问题。具体内容见书180页
> + 然后讲第二点差异，也就是绝对定位元素计算的容器是第一个 position 不为 static 的祖先元素
> + + 而“通常场景下”说的是，有可能我们的“包含块”（或者“包含块”剩余的空间）小到不足以放下“文字内容”这 4 个汉字。于是，一些“怪异”的现象就很好理解了，比方说纯 CSS定位或 JavaScript 计算定位实现的提示效果一柱擎天的问题。[演示地址为](http://demo.cssworld.cn/6/5-1.php)
> + + 我们可以利用::before 和::after 伪元素实现我们想要的效果，一个实现三角，一个实现矩形区。为了不干扰布局，显然实现提示效果的两个伪元素会使用 absolute 绝对定位，为了定位准确，我们会给小图标元素设置 position:relative。此时问题来了：由于提示信息的内容有长有短，我们不可能给提示元素设置一个特定的宽度，于是宽度表现走“包裹性”，也就是最大宽度不超过“包含块”的宽度，但是恰好此时“包含块”就是我们的小图标元素，并且宽度往往都不超过 20 像素，也就是我们的提示信息只能够在 20 像素宽的区域内显示,要修复这一问题其实很简单，只要改变默认的宽度显示类型就可以，添加 white-space: nowrap，让宽度表现从“包裹性”变成“最大可用宽度”，点击演示页面的删除图标可看到修复“一柱擎天”问题后的效果。
> + 最后讲第三点差异，也就是计算和定位是相对于祖先定位元素的 padding box。
    
#### 具有相对特性的无依赖 absolute 绝对定位
> 一个绝对定位元素，没有任何 left/top/right/bottom 属性设置，并且其祖先元素全部都是非定位元素，其位置在哪里？很多人都认为是在浏览器窗口左上方。实际上，还是当前位置，不是在浏览器左上方。
> 请牢记下面这句话：absolute 是非常独立的 CSS 属性值，其样式和行为表现不依赖其他任何 CSS 属性就可以完成。
>  1．各类图标定位
> + 我们经常会在导航右上方增加一个“NEW”或者“HOT”这样的小图标，如图 6-51 所示。要实现在导航文字右上方的定位很简单，直接对加图标这个元素进行样式设定就可以了，原来纯文字导航时的样式完全不需要有一丁点儿的修改。下面以“HOT”图标为例：不仅代码简洁，日后的维护也很方便，更关键的是，即使导航中的文字长度发生了变化，我们的图标依然定位良好，因为“无依赖绝对定位”的图标是自动跟在文字后面显示的

    .icon-hot { 
        position: absolute; 
        margin: -6px 0 0 2px; 
        width: 28px; height: 11px; 
        background: url(hot.gif); 
    }

> 2．超越常规布局的排版
> + [demo](https://demo.cssworld.cn/6/5-6.php)
> + 我们这里把输入框的宽度改小，会看到提示信息会自动跟着往前走，如图 6-55 所示。与容器设置 position:relative 再通过 left 属性实现的定位相比，其代码更简洁，容错性更强，维护成本更低

> 3．[下拉列表的定位](http://demo.cssworld.cn/6/5-7.php)
> 不过这里我有必要补充一点，虽然“无依赖绝对定位”好处多多，但建议只用在静态交互效果上，比方说，导航二级菜单的显示与定位。如果是动态呈现的列表，建议还是使用 JavaScript来计算和定位。

> 4．占位符效果模拟(IE9 及其以下浏览器)

> 5．进一步深入“无依赖绝对定位”。见书（190）

#### absolute 与 text-align
> 按道理讲，absolute 和 float 一样，都可以让元素块状化，应该不会受控制内联元素对齐的 text-align 属性影响，但是最后的结果却出人意料，text-align 居然可以改变absolute 元素的位置
> 虽然本示例中图片位置确实受 text-align 属性影响，但是并不是 text-align 和absolute 元素直接发生关系，absolute 元素的 display 计算值是块状的，text-align是不会有作用的。这里之所以产生了位置变化，本质上是“幽灵空白节点”和“无依赖绝对定位”共同作用的结果。
> + （1）由于\<img>是内联水平，\<p>标签中存在一个宽度为 0、看不见摸不着的“幽灵空白节点”，也是内联水平，于是受 text-align:center 影响而水平居中显示。
> + （2）\<img>设置了 position:absolute，表现为“无依赖绝对定位”，因此在“幽灵空白节点”后面定位显示；同时由于图片不占据空间，这里的“幽灵空白节点”当仁不让，正好在\<p>元素水平中心位置显示，于是我们就看到了图片从\<p>元素水平中间位置显示的效果。
> 按照我的经验，利用 text-align 控制 absolute元素的定位最适合的使用场景就是主窗体右侧的“返回顶部”以及“反馈”等小布局的实现。[例如](http://demo.cssworld.cn/6/5-10.php) 对应的实例页面效果
> 此方法兼容性很好，层级单纯，唯一的问题就是插入了一个空格，会占据一定的高度，这是不推荐的，最好就是有没有“返回顶部”等元素都不影响主结构的布局。所以，我们要把占据的高度抹掉，方法很简单，设置 height：0 同时 overflow:hidden 即可,此时，有人可能会惊呼：什么？设置 height:0 同时 overflow:hidden？那岂不是里面所有元素都被剪裁看不见啦？如果是普通元素确实会如此，但是对于 absolute 绝对定位以及 fixed 固定定位元素，规则要更复杂！

### absolute 与 overflow
> 上面这句话是官方文档的直译，似乎还是有些拗口，我们再换一种方法表述就是：如果overflow 不是定位元素，同时绝对定位元素和 overflow 容器之间也没有定位元素，则overflow 无法对 absolute 元素进行剪裁
> 如果 overflow 的属性值不是 hidden 而是 auto 或者 scroll，即使绝对定位元素高宽比 overflow 元素高宽还要大，也都不会出现滚动条
> transform 除了改变 overflow 属性原有规则，对层叠上下文以及 position:fixed 的渲染都有影响。因此，当大家遇到 absolute 元素被剪裁或者 fixed 固定定位失效时，可以看看是不是 transform 属性在作祟

### absolute 与 clip
> CSS 世界中有些属性或者特性必须和其他属性一起使用才有效，比方说剪裁属性 clip。clip 属性要想起作用，元素必须是绝对定位或者固定定位，也就是 position 属性值必须是absolute 或者 fixed。
> 那具体是如何剪裁的呢？我们看一个例子，CSS 如下：[如图](https://ws1.sinaimg.cn/large/0060ZzrAgy1g8819vjvh4j307b06jmx0.jpg)

    clip: rect(30px 200px 200px 20px)

#### 重新认识的 clip 属性
> 在以下两种场景下具有不可替代的地位
> + 1．fixed 固定定位的剪裁
> + 2．最佳可访问性隐藏

#### 深入了解 clip 的渲染
> 我们先看一个示例：

    .box { 
        width: 300px; height: 100px; 
        background-color: #f0f3f9; 
        position: relative; 
        overflow: auto; 
    } 
    .box > img { 
        width: 256px; height: 192px; 
        position: absolute; 
    }

> 如果对图片进行 clip 剪裁，那效果又将怎样呢？图片显然看不见了，但是注意，在 Chrome 浏览器下，.box 元素的滚动条依旧存在.
> 这个现象很有意思，它说明，至少在 Chrome 浏览器下，clip 仅仅是决定了哪一部分是可见的，对于原来占据的空间并无影响。然而，并不是所有浏览器都这么认为，在 IE 和 Firefox浏览器下是没有滚动条的，只有光秃秃的一小撮背景色在那里。这又是“未定义行为”的表现，看起来 IE 和 Firefox 对于 clip 渲染采用的是另外的方式
> 但是无论怎样，下面这些特性大家的认识都是一致的：使用 clip 进行剪裁的元素其clientWidth 和 clientHeight 包括样式计算的宽高都还是原来的大小，从这一点看，Chrome的渲染似乎更合理。虽然尺寸还是原来的尺寸，但是，隐藏的区域是无法影响我们的点击行为的，说明 clip 隐藏还是很干脆的。

### absolute 的流体特性
#### 当 absolute 遇到 left/top/right/bottom 属性
> 当 absolute 遇到 left/top/right/bottom 属性的时候，absolute 元素才真正变成绝对定位元素

#### absolute 的流体特性
> 说到流体特性，我们通常第一反应就是\<div>之类的普通块级元素。实际上，绝对定位元素也具有类似的流体特性，当然，不是默认就有的，而是在特定条件下才具有，这个条件就是“对立方向同时发生定位的时候”
> 当一个绝对定位元素，其对立定位方向属性同时有具体定位数值的时候，流体特性就发生了。例如：

    <div class="box"></div> 
        .box { 
        position: absolute; 
        left: 0; right: 0; 
    }

> 如果只有 left 属性或者只有 right 属性，则由于包裹性，此时.box 宽度是 0。但是在本例中，因为 left 和 right 同时存在，所以宽度就不是 0，而是表现为“格式化宽度”，宽度大小自适应于.box 包含块的 padding box，也就是说，如果包含块 padding box 宽度发生变化，.box 的宽度也会跟着一起变。
> 绝对定位元素的这种流体自适应特性从 IE7 就开始支持了，但是出于历史习惯或者其他什么原因，很多同行依然使用下面这样的写法：

    .box { 
        position: absolute; 
        left: 0; top: 0; 
        width: 100%; height: 100%; 
    }

> 乍一看，效果都是一样的，但是骨子里却已经严重分化了。后者，也就是设定宽高都是 100%的那个.box，实际上已经完全丧失了流动性，通过上面几个例子可以看到，设置了对立定位属性的绝对定位元素的表现神似普通的\<div>元素，无论设置 padding 还是 margin，其占据的空间一直不变，变化的就是 content box的尺寸，这就是典型的流体表现特性。

#### absolute 的 margin:auto 居中
 >当绝对定位元素处于流体状态的时候，各个盒模型相关属性的解析和普通流体元素都是一模一样的，margin 负值可以让元素的尺寸更大，并且可以使用 margin:auto 让绝对定位元素保持居中。
> 绝对定位元素的 margin:auto 的填充规则和普通流体元素的一模一样：
> + 如果一侧定值，一侧 auto，auto 为剩余空间大小；
> + 如果两侧均是 auto，则平分剩余空间。

### position:relative 才是大哥
#### relative 对 absolute 的限制