## 流的破坏与保护
### 魔鬼属性 float
#### float 的本质与特性
> 认为 float 属性就是为各种块状布局而设计的，实际上不是的。在 Web 诞生之初，带宽就那么一点点，我们能够做到的也只是展示文字以及零星图片而已，怎么可能浮动设计的目的就是为了实现各种砖头式的复杂布局呢？
> 浮动的本质就是为了实现文字环绕效果。而这种文字环绕，主要指的就是文字环绕图片显示的效果。
> 浮动是魔鬼，少砌砖头、少浮动，要更多地去挖掘 CSS 世界本身的“流动性”和“自适应性”，以构建能够适用于各种环境的高质量的网页布局。
> float 都有哪些有意思的特性呢?
> + 包裹性；
> + 块状化并格式化上下文；
> + 破坏文档流；
> + 没有任何 margin 合并；
> 块状化的意思是，元素一旦 float 的属性值不为 none，则其 display 计算值就是 block或者 table。
> 因此，没有任何理由出现下面的样式组合：

    span { 
        display: block; /* 多余 */ 
        float: left; 
    } 
    span { 
        float: left; 
        vertical-align: middle; /* 多余 */ 
    }

> float 属性与 display 属性值转换关系[如表](http://ww1.sinaimg.cn/large/0060ZzrAgy1g7xmt56tlcj30gi0erwf5.jpg)
> 除了 inline-table 计算为 table 外，其他全都是 block。至于 float 元素的块状格式化上下文特性，参见 6.3 节

#### float 的作用机制
> 甚至有些人会问这样的问题：“如何解决浮动让父元素高度塌陷的 bug？”bug？别逗了。一定要明确这一点，浮动使高度塌陷不是 bug，而是标准！有人可能会有疑问了：怎么会有规范让人“干坏事”的？
> float 属性让父元素高度塌陷的原因就是为了实现文字环绕效果。
>要想实现真正的“环绕效果”，就需要另外一个平时大家不太在意的特性，那就是“行框盒子和浮动元素的不可重叠性”，也就是“行框盒子如果和浮动元素的垂直高度有重叠，则行框盒子在正常定位状态下只会跟随浮动元素，而不会发生重叠”。
> 也就是“行框盒子”的区域永远就这么大，只要不改变当前布局方式，我们是无法通过其他 CSS 属性改变这个区域大小的。这就是在 4.3 节提到的浮动后面元素 margin 负无穷大依然无效的原因。就会发现，只有外部的块状容器盒子尺寸变大，而和浮动元素垂直方向有重叠的“行框盒子”依然被限死在那里.
> 我们不妨看下面这个很有学习价值的例子。很多人会有这样的想法，就是认为一个元素只要设置了具体的高度值，就不需要担心 float 属性造成的高度塌陷的问题了，既然有了高度，何来“高度塌陷”。这句话对不对呢？是对的。但是，其中也隐含了陷阱，因为“文字环绕效果”是由两个特性（即“父级高度塌陷”和“行框盒子区域限制”）共同作用的结果，定高只能解决“父级高度塌陷”带来的影响，但是对“行框盒子区域限制”却没有任何效果，结果导致的问题是浮动元素垂直区域一旦超出高度范围，或者下面元素 margin-top 负值上偏移，就很容易使后面的元素发生“环绕效果”
> 虽然肉眼看上去容器和图片一样高，但是，大家都读过5.3 节，应该都知道内联状态下的图片底部是有间隙的，也就是.float 这个浮动元素的实际高度并不是 64px，而是要比 64px 高几像素，带来的问题就是浮动元素的高度超出.father 几像素。
>[实例](http://demo.cssworld.cn/6/1-1.php)

#### float 更深入的作用机制
> + 浮动锚点是 float 元素所在的“流”中的一个点，这个点本身并不浮动，就表现而言更像一个没有 margin、border 和 padding 的空的内联元素
> + 浮动参考指的是浮动元素对齐参考的实体
> 在 CSS 世界中，float 元素的“浮动参考”是“行框盒子”，也就是 float 元素在当前“行框盒子”内定位
> 参考书6.1.3

#### float 与流体布局
> float 通过破坏正常 CSS 流实现 CSS 环绕，带来了烦人的“高度塌陷”的问题，然而，凡事都具有两面性，只要了解透彻，说不定就可以变废为宝、化腐朽为神奇。例如。我们可以利用 float 破坏 CSS 正常流的特性，实现两栏或多栏的自适应布局
> 还记不记得之前小动物环绕的例子？其实我们稍加改造，就能变成一侧定宽的两栏自适应布局，HTML 和 CSS 代码如下：

    <div class="father"> 
        <img src="me.jpg"> 
        <p class="animal">小猫 1，小猫 2，...</p> 
    </div> 
    .father { 
        overflow: hidden; 
    } 
    .father > img { 
        width: 60px; height: 64px; 
        float: left; 
    } 
    .animal { 
        margin-left: 70px; 
    }

> 和文字环绕效果相比，区别就在于.animal 多了一个 margin-left:70px，也就是所有小动物都要跟男主保持至少 70px 的距离，由于图片宽度就 60px，因此不会发生环绕，自适应效果达成。
> 原理其实很简单，.animal 元素没有浮动，也没有设置宽度，因此，流动性保持得很好，设置 margin-left、border-left 或者 padding-left 都可以自动改变 content box 的尺寸，继而实现了宽度自适应布局效果。
> [demo](http://demo.cssworld.cn/6/1-2.php)
> 上面的技巧适用于一侧定宽一侧自适应：如果是宽度不固定，也有办法处理，这会在 6.3.2 节中介绍。如果是百分比宽度，则也是可以的，例如：

    .left { 
        float: left; 
        width: 50%; 
    } 
    .right { 
        margin-left: 50%; 
    }

> 如果是多栏布局，也同样适用，尤其[图](http://ww1.sinaimg.cn/large/0060ZzrAgy1g7yrz1vkhcj30aq01hdfq.jpg)所示的这种布局
> 假设 HTML 结构如下：

    <div class="box"> 
    <a href class="prev">&laquo; 上一章</a> 
    <a href class="next">下一章 &raquo;</a> 
    <h3 class="title">第 112 章 动物环绕</h3> 
    </div>

> 则 CSS 可以如下：

    .prev { 
        float: left; 
    } 
    .next { 
        float: right; 
    } 
    .title { 
        margin: 0 70px; 
        text-align: center; 
    }

### float 的天然克星 clear
#### 什么是 clear 属性
> clear 属性值:
> + none：默认值，左右浮动来就来。
> + left：左侧抗浮动。
> + right：右侧抗浮动。
> + both：两侧抗浮动。
> 我的答案非常直白：没错，确实没有什么用！凡是 clear:left 或者 clear:right 起作用的地方，一定可以使用 clear:both 替换！

> 举个例子，假设容器宽度足够宽，有 10 个\<li>元素，设置了如下 CSS 代码：[如图](http://ww1.sinaimg.cn/large/0060ZzrAgy1g7ys7dkkqbj306801w0km.jpg)

    li { 
        width: 20px; height: 20px; 
        margin: 5px; 
        float: left; 
    } 
    li:nth-of-type(3) { 
        clear: both; 
    }

> 原因在于，clear 属性是让自身不能和前面的浮动元素相邻，注意这里“前面的”3 个字，也就是 clear 属性对“后面的”浮动元素是不闻不问的，因此才 2 行显示而非 3 行。

#### 成事不足败事有余的 clear
> clear 属性只有块级元素才有效的，而::after 等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置 display 属性值的原因。
> 由于 clear:both 的作用本质是让自己不和 float 元素在一行显示，并不是真正意义上的清除浮动，因此 float 元素一些不好的特性依然存在，于是，会有类似下面的现象
> + （1）如果 clear:both 元素前面的元素就是 float 元素，则 margin-top 负值即使设成-9999px，也不见任何效果。
> + （2）clear:both 后面的元素依旧可能会发生文字环绕的现象。举个例子，如下 HTML和 CSS：[如图](http://ww1.sinaimg.cn/large/0060ZzrAgy1g7ysde4bl9j307102pt90.jpg)

    <div class="father"> 
        <img src="zxx.jpg"> 
        我是帅哥，好巧啊，我也是帅哥，原来看这本书的人都是帅哥~ 
    </div> 
    <div>虽然你很帅，但是我对你不感兴趣。</div>
    .father:after {
        content: ''; 
        display: table; 
        clear: both; 
    } 
    .father img { 
        float:left; 
        width: 60px; height: 64px; 
    } 
    .father + div { 
        margin-top: -2px; 
    }

>由此可见，clear:both 只能在一定程度上消除浮动的影响，要想完美地去除浮动元素的影响，还需要使用其他 CSS 声明。那应该使用哪些 CSS 声明呢？请看 6.3 节

### CSS 世界的结界——BFC
#### BFC 的定义
> BFC 全称为 block formatting context，中文为“块级格式化上下文”。相对应的还有 IFC，也就是 inline formatting context，中文为“内联格式化上下”
> 大家请记住下面这个表现原则：如果一个元素具有 BFC，内部子元素再怎么翻江倒海、翻云覆雨，都不会影响外部的元素。所以，BFC 元素是不可能发生 margin 重叠的，因为 margin重叠是会影响外面的元素的；BFC 元素也可以用来清除浮动的影响，因为如果不清除，子元素浮动则父元素高度塌陷，必然会影响后面元素布局和定位，这显然有违 BFC 元素的子元素不会影响外部元素的设定。
> 那什么时候会触发 BFC 呢？常见的情况如下：
> + \<html>根元素；
> + float 的值不为 none；
> + overflow 的值为 auto、scroll 或 hidden；
> + display 的值为 table-cell、table-caption 和 inline-block 中的任何一个；
> + position 的值不为 relative 和 static。

#### BFC 与流体布局
> BFC 的结界特性最重要的用途其实不是去 margin 重叠或者是清除 float 影响，而是实现更健壮、更智能的自适应布局。
> 我们还是从最基本的文字环绕效果说起。还是那个小动物环绕的例子：我们还是从最基本的文字环绕效果说起。还是那个小动物环绕的例子：

    <div class="father"> 
    <img src="me.jpg"> 
    <p class="animal">小猫 1，小猫 2，...</p> 
    </div> 
    img { float: left; }
    
   > 此时.animal 的内容显然受到了设置了 float 属性值的图片的影响而被环绕了。此时如果我们给.animal 元素设置具有 BFC 特性的属性，overflow:hidden，如下：则根据 BFC 的表现原则，具有 BFC 特性的元素的子元素不会受外部元素影响，也不会影响外部元素。于是，这里的.animal 元素为了不和浮动元素产生任何交集，顺着浮动边缘形成自己的封闭上下文
   > 普通流体元素在设置了 overflow:hidden 后，会自动填满容器中除了浮动元素以外的剩余空间，形成自适应布局效果，而且这种自适应布局要比纯流体自适应
更加智能。
> 和基于纯流体特性实现的两栏或多栏自适应布局相比，基于 BFC 特性的自适应布局有如下优点。
> + （1）自适应内容由于封闭而更健壮，容错性更强。比方说，内部设置 clear:both 不会与float 元素相互干扰而导致错位，也就不会发生类似于图 6-22 所示的问题。
> + （2）自适应内容自动填满浮动以外区域，无须关心浮动元素宽度，可以整站大规模应用。比方说，抽象几个通用的布局类名
> 理论上，任何 BFC 元素和 float 元素相遇的时候，都可以实现自动填充的自适应布局。但是，由于绝大多数的触发 BFC 的属性自身有一些古怪的特性，所以，实际操作的时候，能兼顾流体特性和 BFC 特性来实现无敌自适应布局的属性并不多。下面我们一个一个来看，每个CSS 属性选一个代表来进行说明。
> + （1）float:left。浮动元素本身 BFC 化，然而浮动元素有破坏性和包裹性，失去了元素本身的流体自适应性，因此，无法用来实现自动填满容器的自适应布局。不过，其因兼容性还算良好，与搭积木这种现实认知匹配，上手简单，因此在旧时代被大肆使用，也就是常说的“浮动布局”，也算阴差阳错地开创了自己的一套布局。
> + （2）position:absolute。这个脱离文档流有些严重，过于清高，和非定位元素很难玩到一块儿去，我就不说什么了。
> + （3）overflow:hidden。这个超棒！不像浮动和绝对定位，玩得有点儿过。其本身还是一个很普通的元素，因此，块状元素的流体特性保存得相当完好，附上 BFC 的独立区域特性，谓如虎添翼、宇宙无敌！而且 overflow:hidden 的 BFC 特性从 IE7 浏览器开始就支持，兼容性也很不错。唯一的问题就是容器盒子外的元素可能会被隐藏掉，一定程度上限制了这种特性的大规模使用。不过，溢出隐藏的交互场景比例不算很高，所以它还是可以作为常用 BFC布局属性使用的。
> + （4）display:inline-block。这是 CSS 世界最伟大的声明之一，但是用在这里，就有些捉襟见肘了。display:inline-block 会让元素尺寸包裹收缩，完全就不是我们想要的lock 水平的流动特性。只能是一声叹息舍弃掉！然而，峰回路转，世事难料。大家应该知道，IE6 和 IE7 浏览器下，block 水平的元素设置 display:inline-block 元素还是 block 水平，也就是还是会自适应容器的可用宽度显示。于是，对于 IE6 和 IE7 浏览器，我们会阴差阳错得到一个比 overflow:hidden 更强大的声明，既 BFC 特性加身，又流体特性保留
> + （5）display:table-cell。其让元素表现得像单元格一样，IE8 及以上版本浏览器才持。跟 display:inline-block 一样，它会跟随内部元素的宽度显示，看样子也是不合适的命。但是，单元格有一个非常神奇的特性，就是宽度值设置得再大，实际宽度也会超过表格容器的宽度。第 3 章单元格一柱擎天的例子利用的就是这种特性，如图 6-23 所示
> + （6）display:table-row。对 width 无感，无法自适应剩余容器空间。
> + （7）display:table-caption。此属性一无是处。
> 我们对 BFC 声明家族大致过了一遍，能担任自适应布局重任的也就是以下几个。
> + overflow:auto/hidden，适用于 IE7 及以上版本浏览器；
> + display:inline-block，适用于 IE6 和 IE7；
> + display:table-cell，适用于 IE8 及以上版本浏览器。

### 最佳结界 overflow
> 要想彻底清除浮动的影响，最适合的属性不是 clear 而是 overflow。一般使用overflow:hidden，利用 BFC 的“结界”特性彻底解决浮动对外部或兄弟元素的影响。
不过话又说回来，overflow 属性原本的作用指定了块容器元素的内容溢出时是否需要裁剪，也就是“结界”只是其衍生出来的特性，“剪裁”才是其本职工作。

#### overflow 剪裁界线 border box
> 要尽量避免滚动容器设置 padding-bottom 值，除了样式表现不一致外，还会导致 scrollHeight 值不一样，这往往会给开发带来难以察觉的麻烦，需要引起注意。
> 了解 overflow-x 和 overflow-y
> 支持的属性值和 overflow 属性一模一样。
> + visible：默认值。
> + hidden：剪裁。
> + scroll：滚动条区域一直在。
> + auto：不足以滚动时没有滚动条，可以滚动时滚动条出现
> 这种相似性很容易让大家产生一个误区，认为只要 overflow-x 和 overflow-y 设置了上面的属性值，就一定会是这样的表现，实际上 overflow-x 和 overflow-y 的表现规则要比看上去复杂些：如果 overflow-x 和 overflow-y 属性中的一个值设置为 visible 而另外一个设置为 scroll、auto 或 hidden，则 visible 的样式表现会如同 auto。也就是说，除非 overflow-x 和 overflow-y 的属性值都是 visible，否则 visible 会当成 auto 来解析。换句话说，永远不可能实现一个方向溢出剪裁或滚动，另一方向内容溢出显示的效果。

#### overflow 与滚动条
> HTML 中有两个标签是默认可以产生滚动条的，一个是根元素<html>，另一个是文本域<textarea>。之所以可以出现滚动条，是因为这两个标签默认的 overflow 属性值不是visible，从 IE8 浏览器开始，都使用 auto 作为默认的属性值。
> 关于浏览器的滚动条，有以下几个小而美的结论。
> + （1）在 PC 端，无论是什么浏览器，默认滚动条均来自<html>，而不是<body>标签。验证很简单，新建一个空白页面，此时<body>标签的默认 margin 值是.5em，如果滚动条是由<body>标签产生的，那么效果应该如图 6-27 所示这般边缘留有间隙。但是最后实现结果却是图 6-28 所示的这样没有间隙。注意，上述规则只对 PC 端有效，对于移动端并不一定适用。例如，在 PC 端，对<html>标签设置 overflow:hidden 可以隐藏滚动条禁止滚动，但是在移动端基本上无效。在 PC 端，窗体滚动高度可以使用 document.documentElement.scrollTop 获取，但是在移动端，可能就要使用 document.body.scrollTop 获取。
> + （2）滚动条会占用容器的可用宽度或高度。
> 滚动条是可以自定义的,倒是支持-webkit-前缀的浏览器可以说说。例如，对于 Chrome 浏览器：
> + 整体部分，::-webkit-scrollbar；
> + 两端按钮，::-webkit-scrollbar-button；
> + 外层轨道，::-webkit-scrollbar-track；
> + 内层轨道，::-webkit-scrollbar-track-piece；
> + 滚动滑块，::-webkit-scrollbar-thumb；
> + 边角，::-webkit-scrollbar-corner。

#### 依赖 overflow 的样式表现
> 在 CSS 世界中，很多属性要想生效都必须要有其他 CSS 属性配合，其中有一种效果就离不开 overflow:hidden 声明，即单行文字溢出点点点效果。虽然效果的核心是 textoverflow:ellipsis，效果实现必需的 3 个声明如下：

    .ell { 
        text-overflow: ellipsis; 
        white-space: nowrap; 
        overflow: hidden; 
    }

> 目前，对-webkit-私有前缀支持良好的浏览器还可以实现多行文字打点效果，但是却无须依赖 overflow:hidden。比方说，最多显示 2 行内容，再多就打点的核心 CSS 代码如下：

    .ell-rows-2 { 
         display: -webkit-box; 
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 2;
    }

#### overflow 与锚点定位
> 下面思考这两个问题：锚点定位行为是基于什么条件触发的？锚点定位作用的发生本质上是什么在起作用？
> 1．锚点定位行为的触发条件
> + （1）URL 地址中的锚链与锚点元素对应并有交互行为；
> + （2）可 focus 的锚点元素处于 focus 状态。
> 所以我们一般实现返回顶部效果都是使用这样的 HTML：\<a href="#">返回顶部>\</a>
> 然后配合 JavaScript 实现一些动效或者避免点击时候 URL 地址出现#，而很多人实现返回顶部效果的时候使用的是类似下面的 HTML：\<a href="javascript:">返回顶部>\</a>
> 显然我是推荐上面那种做法的，因为锚点定位行为的发生是不需要依赖 JavaScript 的，所以即使页面 JavaScript 代码失效或者加载缓
慢，也不会影响正常的功能体验，也就是用户无论在什么状态下都能准确地返回顶部。
> “focus 锚点定位”指的是类似链接或者按钮、输入框等可以被 focus 的元素在被 focus时发生的页面重定位现象。举个很简单的例子，在 PC 端，我们使用 Tab 快速定位可 focus 的元素的时候，如果我们的元素正好在屏幕之外，浏览器就会自动重定位，将这个屏幕之外的元素定位到屏幕之中。
> 2．锚点定位作用的本质
> 锚点定位行为的发生，本质上是通过改变容器滚动高度或者宽度来实现的。
> “由内而外”指的是，普通元素和窗体同时可滚动的时候，会由内而外触发所有可滚动窗体的锚点定位行为。继续上面的例子，假设我们的浏览
器窗体也是可滚动的，则点击“点击测试”链接后，“底部标题”先触发.box 容器的锚点定位，也就是滚动到底部，然后再触发窗体的锚点定位，“底部标题”和浏览器窗口的上边缘对齐，[如图](http://ww1.sinaimg.cn/large/0060ZzrAgy1g85pggqiyfj306r030q2v.jpg)
> 其次就是设置了 overflow:hidden 的元素也是可滚动的，这也是本小节的核心。说得更干脆点儿就是：overflow:hidden 跟 overflow:auto 和 overflow：scroll 的差别就在于有没有那个滚动条。元素设置了 overflow:hidden 声明，里面内容高度溢出的时候，滚动依然存在，仅仅滚动条不存在！锚点定位本质上是改变了 scrollTop 或scrollLeft 值，因此，上面的定位效果等同于执行了下面的 JavaScript 代码：document.querySelector('.box').scrollTop = 200;
> 那岂不是我们可以利用这种兼容的浏览器行为实现更复杂的无 JavaScript 的交互效果？例如，实现选项卡切换效果，[点击](http://demo.cssworld.cn/6/4-2.php)
> 此效果乍一看很酷，但却有不少不足之处：其一，容器高度需要固定；其二，也是最麻烦的，就是“由内而外”的锚点定位会触发窗体的重定位，也就是说，如果页面也是可以滚动的，则点击选项卡按钮后页面会发生跳动，这种体验显然是非常不好的。那有没有什么解决办法呢？
> 有，还记不记得前面提过有两种方法可以触发锚点定位，其中有一种方法就是“focus 锚点定位”，只要定位的元素在浏览器窗体中，就不会触发窗体的滚动，也就是选项卡切换的时候页面不会发生跳动。[访问基于“focus 锚点定位”](http://demo.cssworld.cn/6/4-3.php),同样，这一技术只适用于高度固定的选项卡效果，如各大站点首页经常出现的幻灯片广告切换效果等。实际上，如果不用考虑 IE8 浏览器，可以利用:checked 伪类、单选按钮和\<label>标签的点击行为实现选项卡切换
> 实现自定义的滚动条效果，因为 Windows 系统下浏览器的滚动条会占据宽度，而且长得不好看，所以就存在实现自定义滚动条的需求，也就是类似移动端的悬浮式滚动条。传统实现都是父容器设置 overflow:hidden，然后子元素使用一个大的\<div>包起来，设置绝对定位，然后通过改变 top 值，或者使用 transform 进行偏移。但是在我看来，最推荐的实现还是基于父容器自身的 scrollTop 值改变来实现自定义滚
动条效果，其好处有如下这些。
> + （1）实实现简单，无须做边界判断。因为就算 scrollTop 设为-999，浏览器依然按照 0 来渲染，要想滚动到底部，直接一个很大的 scrollTop 值就可以了，无须任何计算。例如：container.scrollTop = 99999;
> + （2）可与原生的 scroll 事件天然集成，无缝对接。例如，我们的滚动延迟加载图片效果就可以直接应用，因为图片位置的计算往往都是和 scrollTop 值相关联的，所以传统实现scrollTop 值一直是 0，很可能导致这类组件出现异常。
> + （3）无须改变子元素的结构。传统实现为了定位方便，会给所有的列表元素外面包一层独立的\<div>元素，这可能会导致某些选择器（类似于.container > .list{}）失效，但是，基于父容器本身的 scrollTop 滚动实现则无此问题，即使子元素全是兄弟元素也是可以的。
> 当然，没有哪种技术是万能的，基于改变 overflow:hidden 父容器的 scrollTop 实现自定义滚动条效果也有几点不足：一是无法添加类似 Bounce 回弹这种动效；二是渲染要比一般的渲染慢一些，但大多数场景下用户都是无感知的。

### float 的兄弟 position:absolute
> 为 position:absolute（下简称 absolute）和 float:left/float：right（下简称 float）是兄弟关系，都兼具“块状化”“包裹性”“破坏性”等特性，不少布局场合甚至可以相互替代
> 当 absolute 和 float 同时存在的时候，float属性是无任何效果的
> 元素一旦 position 属性值为 absolute 或 fixed，其display 计算值就是 block 或者 table
> 又比方说两者都能“块状格式化上下文”，也就是 BFC。
> 又比方说两者都具有“包裹性”，也就是尺寸收缩包裹，同时具有自适应性。

#### absolute 的包含块
> 包含块（containing block）这个概念实际上大家一直都有接触，就是元素用来计算和定位的一个框。比方说，width:50%，也就是宽度一半，那到底是哪个“元素”宽度的一半呢？注意，这里的这个“元素”实际上就是指的“包含块”。有经验的人应该都知道，普通元素的百分比宽度是相对于父元素的 content box 宽度计算的，而绝对定位元素的宽度是相对于第一个position 不为 static 的祖先元素计算的。实际上，大家已经和“包含块”打过交道了，对于这些计算规则，规范是有明确定义的，具体如下（剔除了不常用的部分内容）。
> + （1）根元素（很多场景下可以看成是<html>）被称为“初始包含块”，其尺寸等同于浏览器可视窗口的大小。
> + （2）对于其他元素，如果该元素的 position 是 relative 或者 static，则“包含块”由其最近的块容器祖先盒的 content box 边界形成。
> + （3）如果元素 position:fixed，则“包含块”是“初始包含块”。
> + （4）如果元素 position:absolute，则“包含块”由最近的 position 不为 static的祖先元素建立，具体方式如下。[纯inline元素](http://ww1.sinaimg.cn/large/0060ZzrAgy1g85pz51ipxj30la05gwgf.jpg),如果该祖先元素是纯 inline 元素，则规则略复杂：
> + + 假设给内联元素的前后各生成一个宽度为 0 的内联盒子（inline box），则这两个内联盒子的 padding box 外面的包围盒就是内联元素的“包含块”；
> + + 如果该内联元素被跨行分割了，那么“包含块”是未定义的，也就是 CSS2.1规范并没有明确定义，浏览器自行发挥。
> + + 否则，“包含块”由该祖先的 padding box 边界形成。
> + + 如果没有符合条件的祖先元素，则“包含块”是“初始包含块”。
> + 可以看到，和常规元素相比，absolute 绝对定位元素的“包含块”有以下 3 个明显差异：
> + + （1）内联元素也可以作为“包含块”所在的元素；
> + + （2）“包含块”所在的元素不是父块级元素，而是最近的 position 不为 static 的祖先元素或根元素；
> + + （3）边界是 padding box 而不是 content box。
> + 首先讲第一点差异，也就是内联元素可以作为“包含块”。这一点估计很多人都不知道，因为平时使用得少。为何平时用得少？原因如下。
> + + （1）我们一旦使用 absolute 绝对定位，基本上都是用来布局，而内联元素主要的作用是图文展示，所谓道不同不相为谋，因此两者很难凑到一块儿。
> + + （2）理解和学习成本比较高。
> + + （3）兼容性问题。