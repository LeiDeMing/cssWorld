## 3.1
+ 标签分为两类 块级元素(block-level element) 和 内联元素(inline element)
+ + 常见的块级元素有\<div>、\<li>和\<table>等,需要注意是，“块级元素”和“display 为 block 的元素”不是一个概念。例如，\<li>元素默认的 display 值是 list-item，\<table>元素默认的 display 值是 table，但是它们均是“块级元素”，因为它们都符合块级元素的基本特征，也就是一个水平流上只能单独显示一个元素，多个块级元素则换行显示。

### 块级元素
> 基本特征，也就是一个水平流上只能单独显示一个元素，多个块级元素则换行显示
+ 正是由于“块级元素”具有换行特性，因此理论上它都可以配合 clear 属性来清除浮动带来的影响(清除浮动原理？)
    
    .clear:after { 
        content: ''; 
        display: table; // 也可以是 block，或者是 list-item 
        clear: both; 
    }

+ list-item——出现项目符号,这个符号被称为“标记盒子”（marker box），专门用来放圆点、数字这些项目符号,IE浏览器下伪元素不支持 list-item 或许就是无法创建这个“标记盒子”导致的
+ 块级盒子（block-level box）和内联盒子（inline box）。块级盒子就负责结构，内联盒子就负责内容
+ 按照 display 的属性值不同，值为 block 的元素的盒子实际由外在的“块级盒子”和内在的“块级容器盒子”组成(满足display:inline-block属性)，外在盒子负责元素是可以一行显示，还是只能换行显示；内在盒子负责宽高、内容呈现什么的

##### [思维导图](https://www.processon.com/view/5d9011ebe4b0feb00875e5a8#map)

### 深藏不露的 width:auto
+ （1）充分利用可用空间。比方说，<div>、<p>这些元素的宽度默认是 100%于父级容器的
+ （2）收缩与包裹。典型代表就是浮动、绝对定位、inline-block 元素或 table 元素，英文称为 shrink-to-fit，直译为“收缩到合适”，有那么点儿意思，但不够形象，我一直把这种现象称为“包裹性”。
+ （3）收缩到最小。这个最容易出现在 table-layout 为 auto 的[表格中](http://demo.cssworld.cn/3/2-1.php)
+ （4）超出容器限制。除非有明确的 width 相关设置，否则上面 3 种情况尺寸都不会主动超过父级容器宽度的，但是存在一些特殊情况。例如，内容很长的连续的英文和数字，或者内联元素被设置了 white-space:nowrap，则表现为“恰似一江春水向东流，流到断崖也不回头”。
> 盒子分“内在盒子”和“外在盒子”，显示也分“内部显示”和“外部显示”，同样地，尺寸也分“内部尺寸”和“外部尺寸”。其中“内部尺寸”英文写作“Intrinsic Sizing”，表示尺寸由内部元素决定；还有一类叫作“外部尺寸”，英文写作“Extrinsic Sizing”，宽度由外部元素决定

#### 格式化宽度
+ 格式化宽度仅出现在“绝对定位模型”中，也就是出现在 position属性值为 absolute 或 fixed 的元素中。在默认情况下，绝对定位元素的宽度表现是“包裹性”，宽度由内部尺寸决定，但是，有一种情况其宽度是由外部尺寸决定的，是什么情况呢？

#### 外部尺寸与流体特性
+ （1）正常流宽度。当我们在一个容器里倒入足量的水时，水一定会均匀铺满整个容器
+ （2）格式化宽度。格式化宽度仅出现在“绝对定位模型”中，也就是出现在 position属性值为 absolute 或 fixed 的元素中。在默认情况下，绝对定位元素的宽度表现是“包裹性”，宽度由内部尺寸决定，但是，有一种情况其宽度是由外部尺寸决定的，是什么情况呢？对于非替换元素（见本书第 4 章），当 left/top 或 top/bottom 对立方位的属性值同时存在的时候，元素的宽度表现为“格式化宽度”，其宽度大小相对于最近的具有定位特性（position 属性值不是 static）的祖先元素计算

#### 内部尺寸与流体特性
> 如何快速判断一个元素使用的是否为“内部尺寸”呢？很简单，假如这个元素里面没有内容，宽度就是 0，那就是应用的“内部尺寸”
+ （1）包裹性
+ （2）首选最小宽度
+ （3）最大宽度-如果内部没有块级元素或者块级元素没有设定宽度值，则“最大宽度”实际上是最大的连续内联盒子(理解为 display 为        inline、inline-block、inline-table 等元素,“连续内联盒子”指的全部都是内联级别的一个或一堆元素，中间没有任何的换行标签<br>或其他块级元素)的宽度
+ 除了 inline-block 元素，浮动元素以及绝对定位元素都具有包裹性，均有类似的智能宽度行为

### width 值作用的细节
+ “内在盒子”又被分成了 4 个盒子，分别是 content box、padding box、border box和 margin box

### CSS 流体布局下的宽度分离原则
> 所谓“宽度分离原则”，就是 CSS 中的 width 属性不与影响宽度的 padding/border（有时候包括 margin）属性共存，也就是不能出现以下的组合

    .box { width: 100px; border: 1px solid; }

或者

    .box { width: 100px; padding: 20px; }

### 改变 width/height 作用细节的 box-sizing
> box-sizing 就是改变尺寸作用规则的

#### 如何评价*{box-sizing:border-box}
+ （1）这种做法易产生没必要的消耗
+ （2）这种做法并不能解决所有问题

#### box-sizing 发明的初衷
> box-sizing 被发明出来最大的初衷应该是解决替换元素宽度自适应问题

    input, textarea, img, video, object { 
        box-sizing: border-box; 
    }

### 关于 height:100%
+ height 和 width 还有一个比较明显的区别就是对百分比单位的支持。对于 width 属性，就算父元素 width 为 auto，其百分比值也是支持的；但是，对于 height 属性，如果父元素height 为 auto，只要子元素在文档流中，其百分比值完全就被忽略了

#### 1．为何 height:100%无效
+ 了解浏览器渲染的基本原理。首先，先下载文档内容，加载头部的样式资源（如果有的话），然后按照从上而下、自外而内的顺序渲染 DOM 内容。套用本例就是，先渲染父元素，后渲染子元素，是有先后顺序的。因此，当渲染到父元素的时候，子元素的width:100%并没有渲染，宽度就是图片加文字内容的宽度；等渲染到文字这个子元素的时候，父元素宽度已经固定，此时的 width:100%就是已经固定好的父元素的宽度。宽度不够怎么办？溢出就好了，overflow 属性就是为此而生的
+ 规范中其实给出了答案。如果包含块的高度没有显式指定（即高度由内容决定），并且该元素不是绝对定位，则计算值为auto。一句话总结就是：因为解释成了 auto。要知道，auto 和百分比计算，肯定是算不了的：'auto' * 100/100 = NaN
#### 2. 如何让元素支持 height:100%效果
+ （1）设定显式的高度值。这个没什么好说的，例如，设置 height:600px，或者可以生效的百分比值高度
+ （2）使用绝对定位。绝对定位元素的百分比计算和非绝对定位元素的百分比计算是有区别的，区别
在于绝对定位的宽高百分比计算是相对于 padding box 的，也就是说会把 padding 大小值计算
在内，但是，非绝对定位元素则是相对于 content box 计算的

### 3.3 CSS min-width/max-width和min-height/max-height二三事

#### 3.3.2 与众不同的初始值

+ （1）min-wdith/height 值为 auto 合法
+ （2）数值变化无动画

#### 3.3 超越!important，超越最大
+ 1．超越!important
> 超越!important 指的是 max-width 会覆盖 width，而且这种覆盖不是普通的覆盖，是超级覆盖，覆盖到什么程度呢？大家应该都知道 CSS 世界中的!important 的权重相当高，在业界，往往会把!important 的权重比成“泰坦尼克”，比直接在元素的 style 属性中设置 CSS 声明还要高，一般用在 CSS 覆盖 JavaScript 设置上。但是，就是这么厉害的!important，直接被 max-width 一个浪头就拍沉了

+ 2．超越最大
> 超越最大指的是min-width覆盖max-width，此规则发生在min-width和max-width冲突的时候

#### 3.3.4 任意高度元素的展开收起动画技术

    .element { 
        max-height: 0; 
        overflow: hidden; 
        transition: max-height .25s; 
    } 
    .element.active { 
        max-height: 666px; /* 一个足够大的最大高度值 */ 
    }

> 建议 max-height 使用足够安全的最小值，这样，收起时即使有延迟，也会因为时间很短，很难被用户察觉，并不会影响体验

### 内联元素
> inline 和 block几乎瓜分了剩下的全部江山，是流体布局的本质所在。从作用上来讲，块级负责结构，内联负责内容。CSS 世界是为图文展示而设计的。所谓图文，指图片和文字，是最典型的内联元素。所以，在 CSS 世界中，内联元素是最为重要的，涉及的 CSS 属性也非常之多，这些 CSS 属性往往具有继承特性，混合在一起会导致 CSS 解析规则非常复杂。这就是内联元素的解析比块级元素解析更难理解的原因

#### 3.4.3 幽灵空白节点
> 文档声明必须是 HTML5 文档声明（HTML 代码如下），如果还是很多年前的老声明，则不存在“幽灵空白节点”。
