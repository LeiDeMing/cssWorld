## 3.1
+ 标签分为两类 块级元素(block-level element) 和 内联元素(inline element)
+ 常见的块级元素有\<div>、\<li>和\<table>等,需要注意是，“块级元素”和“display 为 block 的元素”不是一个概念。例如，\<li>元素默认的 display 值是 list-item，\<table>元素默认的 display 值是 table，但是它们均是“块级元素”，因为它们都符合块级元素的基本特征，也就是一个水平流上只能单独显示一个元素，多个块级元素则换行显示。

### 块级元素
    基本特征，也就是一个水平流上只能单独显示一个元素，多个块级元素则换行显示实际开发时，我们要么使用 block，要么使用table，并不会使用 list-item，主要有 3 个原因。
> + （1）1 个字符的比较多，其他都是 5 个字符。
> + （2）会出现不需要的项目符号，如图 3-2 箭头所示。这其实并不是什么大问题，再加一行 list-style: none 声明就可以了。
> + （3）IE 浏览器不支持伪元素的 display 值为 list-item。这是不使用 display:list-item 清除浮动的主因，兼容性不好。对于 IE 浏览器（包括 IE11），普通元素设置 display:list-item 有效，但是 :before /:after 伪元素就不行。
+ 正是由于“块级元素”具有换行特性，因此理论上它都可以配合 clear 属性来清除浮动带来的影响(清除浮动原理？)
    
    .clear:after { 
        content: ''; 
        display: table; // 也可以是 block，或者是 list-item 
        clear: both; 
    }

+ list-item——出现项目符号,这个符号被称为“标记盒子”（marker box），专门用来放圆点、数字这些项目符号,IE浏览器下伪元素不支持 list-item 或许就是无法创建这个“标记盒子”导致的
+ 块级盒子（block-level box）和内联盒子（inline box）。块级盒子就负责结构，内联盒子就负责内容
+ 按照 display 的属性值不同，值为 block 的元素的盒子实际由外在的“块级盒子”和内在的“块级容器盒子”组成(满足display:inline-block属性)，外在盒子负责元素是可以一行显示，还是只能换行显示；内在盒子负责宽高、内容呈现什么的


### 深藏不露的 width:auto
+ （1）充分利用可用空间。比方说，\<div>、\<p>这些元素的宽度默认是 100%于父级容器的
+ （2）收缩与包裹。典型代表就是浮动、绝对定位、inline-block 元素或 table 元素，英文称为 shrink-to-fit，直译为“收缩到合适”，有那么点儿意思，但不够形象，我一直把这种现象称为“包裹性”。
+ （3）收缩到最小。这个最容易出现在 table-layout 为 auto 的[表格中](http://demo.cssworld.cn/3/2-1.php)
+ （4）超出容器限制。除非有明确的 width 相关设置，否则上面 3 种情况尺寸都不会主动超过父级容器宽度的，但是存在一些特殊情况。例如，内容很长的连续的英文和数字，或者内联元素被设置了 white-space:nowrap，则表现为“恰似一江春水向东流，流到断崖也不回头”。
> 盒子分“内在盒子”和“外在盒子”，显示也分“内部显示”和“外部显示”，同样地，尺寸也分“内部尺寸”和“外部尺寸”。其中“内部尺寸”英文写作“Intrinsic Sizing”，表示尺寸由内部元素决定；还有一类叫作“外部尺寸”，英文写作“Extrinsic Sizing”，宽度由外部元素决定

#### 外部尺寸与流体特性
+ （1）正常流宽度。当我们在一个容器里倒入足量的水时，水一定会均匀铺满整个容器
+ （2）格式化宽度。格式化宽度仅出现在“绝对定位模型”中，也就是出现在 position属性值为 absolute 或 fixed 的元素中。在默认情况下，绝对定位元素的宽度表现是“包裹性”，宽度由内部尺寸决定，但是，有一种情况其宽度是由外部尺寸决定的，是什么情况呢？对于非替换元素（见本书第 4 章），当 left/top 或 top/bottom 对立方位的属性值同时存在的时候，元素的宽度表现为“格式化宽度”，其宽度大小相对于最近的具有定位特性（position 属性值不是 static）的祖先元素计算

#### 内部尺寸与流体特性
> 如何快速判断一个元素使用的是否为“内部尺寸”呢？很简单，假如这个元素里面没有内容，宽度就是 0，那就是应用的“内部尺寸”
+ （1）包裹性
+ > “包裹性”对实际开发有什么作用呢？请看这个需求：页面某个模块的文字内容是动态的，可能是几个字，也可能是一句话。然后，希望文字少的时候居中显示，文字超过一行的时候居左显示。该如何实现？[如图](https://ws1.sinaimg.cn/large/0060ZzrAgy1gabbasogykj30j704tmxb.jpg)
+ （2）[首选最小宽度](http://demo.cssworld.cn/3/2-6.php)
+ > “首选最小宽度”对我们实际开发有什么作用呢？可以让我们遇到类似现象的时候知道原因是什么，方便迅速对症下药，其他就没什么用了。
有点失望？那好，我就举个利用“首选最小宽度”构建图形的例子吧。请问，如何使用一层 HTML 标签分别实现图 3-13 所示的“凹”和“凸”效果（注意要兼容 IE8）？想看在线演示，请手动输入 http://demo.cssworld.cn/3/2-6.php 或者扫右侧的二维码。
+ （3）最大宽度-如果内部没有块级元素或者块级元素没有设定宽度值，则“最大宽度”实际上是最大的连续内联盒子(理解为 display 为inline、inline-block、inline-table 等元素,“连续内联盒子”指的全部都是内联级别的一个或一堆元素，中间没有任何的换行标签\<br>或其他块级元素)的宽度
+ 除了 inline-block 元素，浮动元素以及绝对定位元素都具有包裹性，均有类似的智能宽度行为


    .box { 
        text-align: center; 
    } 
    .content { 
        display: inline-block; 
        text-align: left; 
    }


### width 值作用的细节
+ “内在盒子”又被分成了 4 个盒子，分别是 content box、padding box、border box和 margin box
+ [盒尺寸](https://ws1.sinaimg.cn/large/0060ZzrAgy1gabbufq9akj30j608lq46.jpg)
+ 为何唯独 margin box 并没有对应的 CSS 关键字名称呢？因为目前没有任何场景需要用到 margin box。“margin 的背景永远是透明的”，因此不可能作为 backgound-clip 或 background-origin 属性值出现。margin 一旦设定具体宽度和高度值，其本身的尺寸是不会因 margin值变化而变化的，因此作为 box-sizing 的属性值存在也就没有了意义（这会在后面深入阐述）。既然无用武之地，自然就被抛弃了
+ 比方说，对于一个\<div>元素，我们设定其宽度为 100px,如果单看定义和表现，似乎一切都合情合理，但实际上，多年的实践告诉我，有时候，这种宽度设定和表现并不合理。我总结为以下两点
+ + （1）流动性丢失。对于块状元素，如果 width:auto，则元素会如水流般充满整个容器，而一旦设定了 width具体数值，则元素的流动性就会被阻断，因为元素给定宽度就像河流中间竖了两个大闸一样，就没有了流动性。尤其宽度作用在 content box 上，更是内外流动性全无
+ + （2）与现实世界表现不一致的困扰。包含 padding 或 border 会让元素宽度变大的这种 CSS 表现往往会让 CSS 使用者困惑：我设置宽度为 100 像素，其实是希望整个最终的宽度是 100 像素，这样才符合现实理解嘛。比方说，我买个 140m2的房子，肯定是连墙体面积在内的啊，实际使用面积比 140m2 小才是现实，你说现在最终面积比 140m2还大，这种事情显然是不科学不合理的

### CSS 流体布局下的宽度分离原则
> 所谓“宽度分离原则”，就是 CSS 中的 width 属性不与影响宽度的 padding/border（有时候包括 margin）属性共存，也就是不能出现以下的组合

    .box { width: 100px; border: 1px solid; }

或者

    .box { width: 100px; padding: 20px; }

### 改变 width/height 作用细节的 box-sizing
> box-sizing 就是改变尺寸作用规则的

    .box1 { box-sizing: content-box; } /* 默认值 */ 
    .box2 { box-sizing: padding-box; } /* Firefox 曾经支持 */ 
    .box3 { box-sizing: border-box; } /* 全线支持 */ 
    .box4 { box-sizing: margin-box; } /* 从未支持过 */
> 为何 box-sizing 不支持 margin-box
> + 我个人认为，不支持 margin-box 最大的原因是它本身就没有价值！我们不妨好好想想，一个元素，如果我们使用 width 或 height 设定好了尺寸，请问，我们此时设置 margin值，其 offset 尺寸会有变化吗？不会啊，100 像素宽的元素，再怎么设置 margin，它还是 100 像素宽。但是，border 和 padding 就不一样了，100 像素宽的元素，设置个 20 像素大小的 padding 值，offsetWidth 就是 140 像素了，尺寸会变化。你说，一个本身并不会改变元素尺寸的盒子，它有让 box-sizing 支持的道理吗？box-sizing 就是改变尺寸作用规则的！margin 只有在 width 为 auto 的时候可以改变元素的尺寸，但是，此时元素已经处于流动性状态，根本就不需要 box-sizing。所以，说来说去就是 margin-box本身就没有价值
> + 另外一个原因牵扯到语义。如果 box-sizing 开了先河支持了 margin-box，margin box 就变成了一个“显式的盒子”，你让background-origin等属性何去何从，支持还是不支持呢？“margin的背景永远是透明的”这几个大字可是在规范写得清清楚楚，难道让背景色在所谓的 margin box 中也显示？

#### 如何评价*{box-sizing:border-box}
+ （1）这种做法易产生没必要的消耗,对于普通内联元素（非图片等替换元素），box-sizing 无论是什么值，对其渲染表现都没有影响，因此，对这些元素而言就是没有必要的消耗；同时有些元素，如 search类型的搜索框，其默认的 box-sizing 就是 border-box（如果浏览器支持），因此，对search 类型的\<input>而言也是没有必要的消耗
+ （2）这种做法并不能解决所有问题,box-sizing 不支持 margin-box，只有当元素没有水平 margin 时候，box-sizing 才能真正无计算，而“宽度分离”等策略则可以彻底解决所有的宽度计算的问题。因此，我们有必要好好地想一想，box-sizing 属性发明的初衷到底是什么？是为了让那些对 block 水平元素滥用 width 属性的人少出 bug 吗？我不这么认为！

#### box-sizing 发明的初衷
> box-sizing 被发明出来最大的初衷应该是解决替换元素宽度自适应问题

    input, textarea, img, video, object { 
        box-sizing: border-box; 
    }

### 关于 height:100%
+ height 和 width 还有一个比较明显的区别就是对百分比单位的支持。对于 width 属性，就算父元素 width 为 auto，其百分比值也是支持的；但是，对于 height 属性，如果父元素height 为 auto，只要子元素在文档流中，其百分比值完全就被忽略了

#### 1．为何 height:100%无效
+ 了解浏览器渲染的基本原理。首先，先下载文档内容，加载头部的样式资源（如果有的话），然后按照从上而下、自外而内的顺序渲染 DOM 内容。套用本例就是，先渲染父元素，后渲染子元素，是有先后顺序的。因此，当渲染到父元素的时候，子元素的width:100%并没有渲染，宽度就是图片加文字内容的宽度；等渲染到文字这个子元素的时候，父元素宽度已经固定，此时的 width:100%就是已经固定好的父元素的宽度。宽度不够怎么办？溢出就好了，overflow 属性就是为此而生的
+ 规范中其实给出了答案。如果包含块的高度没有显式指定（即高度由内容决定），并且该元素不是绝对定位，则计算值为auto。一句话总结就是：因为解释成了 auto。要知道，auto 和百分比计算，肯定是算不了的：'auto' * 100/100 = NaN
#### 2. 如何让元素支持 height:100%效果
+ （1）设定显式的高度值。这个没什么好说的，例如，设置 height:600px，或者可以生效的百分比值高度
+ （2）使用绝对定位。绝对定位元素的百分比计算和非绝对定位元素的百分比计算是有区别的，区别在于绝对定位的宽高百分比计算是相对于 padding box 的，也就是说会把 padding 大小值计算在内，但是，非绝对定位元素则是相对于 content box 计算的

### 3.3 CSS min-width/max-width和min-height/max-height二三事

#### 3.3.1 为流体而生的 min-width/max-width
> 在公众号的热门文章中，经常会有图片，这些图片都是用户上传产生的，因此尺寸会有大有小，为了避免图片在移动端展示过大影响体验，常常会有下面的 max-width 限制：

    img { 
        max-width: 100%; 
        height: auto!important; 
    }

#### 3.3.2 与众不同的初始值

+ （1）min-wdith/height 值为 auto 合法
+ （2）数值变化无动画

#### 3.3 超越!important，超越最大
+ 1．超越!important
> 超越!important 指的是 max-width 会覆盖 width，而且这种覆盖不是普通的覆盖，是超级覆盖，覆盖到什么程度呢？大家应该都知道 CSS 世界中的!important 的权重相当高，在业界，往往会把!important 的权重比成“泰坦尼克”，比直接在元素的 style 属性中设置 CSS 声明还要高，一般用在 CSS 覆盖 JavaScript 设置上。但是，就是这么厉害的!important，直接被 max-width 一个浪头就拍沉了

+ 2．超越最大
> 超越最大指的是min-width覆盖max-width，此规则发生在min-width和max-width冲突的时候

#### 3.3.4 任意高度元素的展开收起动画技术

    .element { 
        max-height: 0; 
        overflow: hidden; 
        transition: max-height .25s; 
    } 
    .element.active { 
        max-height: 666px; /* 一个足够大的最大高度值 */ 
    }

> 建议 max-height 使用足够安全的最小值，这样，收起时即使有延迟，也会因为时间很短，很难被用户察觉，并不会影响体验

### 内联元素
> inline 和 block几乎瓜分了剩下的全部江山，是流体布局的本质所在。从作用上来讲，块级负责结构，内联负责内容。CSS 世界是为图文展示而设计的。所谓图文，指图片和文字，是最典型的内联元素。所以，在 CSS 世界中，内联元素是最为重要的，涉及的 CSS 属性也非常之多，这些 CSS 属性往往具有继承特性，混合在一起会导致 CSS 解析规则非常复杂。这就是内联元素的解析比块级元素解析更难理解的原因
+ 1．从定义看,首先要明白这一点：“内联元素”的“内联”特指“外在盒子”，和“display 为 inline的元素”不是一个概念！inline-block 和 inline-table 都是“内联元素”，因为它们的“外在盒子”都是内联盒子。自然 display:inline 的元素也是“内联元素”，那么，\<button>按钮元素是内联元素，因为其 display 默认值是 inline-block；\<img>图片元素也是内联元素，因为其 display 默认值是 inline 等。
+ 2．从表现看,就行为表现来看，“内联元素”的典型特征就是可以和文字在一行显示。因此，文字是内联元素，图片是内联元素，按钮是内联元素，输入框、下拉框等原生表单控件也是内联元素。下面有一个疑问：浮动元素貌似也是可以和文字在一个水平上显示的，是不是浮动元素也是内联级别的呢？不是的。实际上，浮动元素和后面的文字并不在一行显示，浮动元素已经在文档流之外了。证据就是，当后面文字足够多的时候，文字并不是在浮动元素的下面，而是继续在后面。这就说明，浮动元素和后面文字不在一行，只是它们恰好站在了一起而已。真相是，浮动元素会生成“块盒子”，这就是后话了。

#### 3.4.2 内联世界深入的基础—内联盒模型
+ （1）[内容区域（content area）](https://ws1.sinaimg.cn/large/0060ZzrAgy1gaejbnav2lj30an025gll.jpg)。内容区域指一种围绕文字看不见的盒子，其大小仅受字符本身特性控制，本质上是一个字符盒子（character box）；但是有些元素，如图片这样的替换元素，其内容显然不是文字，不存在字符盒子之类的，因此，对于这些元素，内容区域可以看成元素自身。
+ （2）内联盒子（inline box）。“内联盒子”不会让内容成块显示，而是排成一行，这里的“内联盒子”实际指的就是元素的“外在盒子”，用来决定元素是内联还是块级。该盒子又可以细分为[“内联盒子”和“匿名内联盒子”两类：](https://ws1.sinaimg.cn/large/0060ZzrAgy1gaejcsjr1tj30dg019q2w.jpg),如果外部含内联标签（\<span>、\<a>和\<em>等），则属于“内联盒子”（实线框标注）；如果是个光秃秃的文字，则属于“匿名内联盒子”（虚线框标注）。需要注意的是，并不是所有光秃秃的文字都是“匿名内联盒子”，其还有可能是“匿名块级盒子”，关键要看前后的标签是内联还是块级。
+ （3）行框盒子（line box）。[例如](https://ws1.sinaimg.cn/large/0060ZzrAgy1gaejekkfvmj30df01aq2u.jpg),每一行就是一个“行框盒子”（实线框标注），每个“行框盒子”又是由一个一个“内联盒子”组成的。
+ （4）包含盒子（containing box）。[例如](https://ws1.sinaimg.cn/large/0060ZzrAgy1gaejfhg69rj30cm01bmx2.jpg),\<p>标签就是一个“包含盒子”（实线框标注），此盒子由一行一行的“行框盒子”组成。需要补充说明一点，在 CSS 规范中，并没有“包含盒子”的说法，更准确的称呼应该是“包含块”（containing block）。这里之所以把它称为盒子，一是为了与其他盒子名称统一，二是称为盒子更形象、更容易理解。


#### 3.4.3 幽灵空白节点
> 文档声明必须是 HTML5 文档声明（HTML 代码如下），如果还是很多年前的老声明，则不存在“幽灵空白节点”。

    <!doctype html> 
    <html>
